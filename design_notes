NOTE
To the below, I might want to add either handle classes or
abstract interface classes - to separate interface from implementation,
as recommended by "Effective C++".

E.g.:
[start example]
Database
  boost::shared_ptr<DatabaseImpl> pimpl
[end example]

SUMMARY OF PHATBOOKS-SPECIFIC CLASSES

Session
  Entity entity

Database
  std::string filepath

Entity
  Database database
  std::vector<int> record_of_journals_to_be_resolved  // For tracking non-finalized FX transactions - there could be a very superficial interface to help users enter these in the first place
  int commodity_id

Date
  (probably just typedef some Boost date class)

Account
  enum AccountType { balance_sheet, profit_and_loss }
  AccountType account_type
  std::string name
  int commodity_id
  int id

Envelope
  std::string name
  int id

Journal
  enum Status { working, saved, posted }
  Status status
  Date date
  std::vector<id> entry_ids
  int id

Entry
  enum Status {	working, saved, posted }
  Status status
  int account_id
  jewel::Decimal amount
  int journal_id
  int id

Commodity
  std::string name
  std::string abbreviation
  int id

Repeater
  Date next_due_date
  enum IntervalScale { daily, monthly,... }
  IntervalScale interval_scale
  int journal_id
  int interval_units
  int id

---

In a transaction in which net assets changes, we must specify at least
one AssetLiabilityAccount, at least one ProfitAndLossAccount, and at least
one EnvelopeAccount.

"Conditions A"
CR (DR) to AssetLiabilityAccount =
DR (CR) to ProfitAndLossAccount =
CR (DR) to EnvelopeAccount.

An EnvelopeAccount is simply another way of classifying net assets.

Because there are three entries, the sum of the three entries equals the
change in net assets resulting from the transaction. Transactions do not
balance to zero! Nevertheless, there are integrity checks that we can do.
Any transaction that does not change net assets should balance to zero.
In any transaction that does change net assets, we can verify that the
conditions stated above (Conditions A) are satisfied.

To allow different commodities, an account balance is actually a container
of different Money objects. Each money object consists of commodity and a
decimal quantity.

...

OK I really like the following.

A journal is a series of entries, each with a date.
The general ledger is itself a journal.
One journal can be added to another journal.

Each journal also has a "reduction", for a given pair of dates. This takes
all entries between those dates, and totals them across each account.
A trial balance of the general ledger across all dates.

When a journal is posted, it is added to the journal that is the general
ledger.

When a recurring journal is posted it is, like a regular journal, added to
the general ledger.

A journal has certain characteristics, one of which is Repeater
characteristics. A journal can be one-off, in which case it is posted only
once; or it can be recurring.

Changes in a journal's Repeater characteristics and also other
"meta-characteristics", are also logged in the journal itself.


An account has a commodity and quantity.
We could have accounts that have a unique commodity (a particular book, for
example), and a quantity of one.

A commodity must be defined to convert to the base commodity for a given
ledger, at a particular rate. The rate could be nil.

A superacccount will still have a given commodity, and will have a balance
that is the sum of its children's balances, after each is converted into the
superaccount's commodity.

...

Should I have interface classes for accounts etc.? Then each instance of the
interface class could have a single data member being a (smart) pointer to
the underlying account. At the moment I can't see any pressing need to add
this extra layer of indirection; but I might do so later. I think it's best
to avoid complicating things unless and until I see the need.

I think I should definitely unit test this program on an ongoing basis during
development.















