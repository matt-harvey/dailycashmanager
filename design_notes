CLASSES

NOTE
To the below, I need to add either handle classes or
abstract interface classes - to separate interface and implementation,
as recommended by "Effective C++".

E.g.:
[start example]
Database
  boost::shared_ptr<DatabaseImpl> pimpl

[end example]

Database
  std::string name
  std::string filepath

Identifier
  std::string str_rep
  Database location
 
StoredObject
  save()
  virtual StoredObject load(Identifier)
  Identifier id

Account: public StoredObject

EnvelopeAccount: public Account

BalanceSheetAccount: public Account

PLAccount: public Account

Journal: public StoredObject

DraftJournal: public Journal

RecurringJournal: public Journal

PostedJournal: public Journal

Entry: public StoredObject

Commodity: public StoredObject

Decimal
  ... a wrapper around an appropriate
  boost::rational object

Repeater: public StoredObject

Table

UserInterface

Application


...

In a transaction in which net assets changes, we must specify at least
one AssetLiabilityAccount, at least one ProfitAndLossAccount, and at least
one EnvelopeAccount.

"Conditions A"
CR (DR) to AssetLiabilityAccount =
DR (CR) to ProfitAndLossAccount =
CR (DR) to EnvelopeAccount.

An EnvelopeAccount is simply another way of classifying net assets.

Because there are three entries, the sum of the three entries equals the
change in net assets resulting from the transaction. Transactions do not
balance to zero! Nevertheless, there are integrity checks that we can do.
Any transaction that does not change net assets should balance to zero.
In any transaction that does change net assets, we can verify that the
conditions stated above (Conditions A) are satisfied.

To allow different commodities, an account balance is actually a container
of different Money objects. Each money object consists of commodity and a
decimal quantity.

...

OK I really like the following.

A journal is a series of entries, each with a date.
The general ledger is itself a journal.
One journal can be added to another journal.

Each journal also has a "reduction", for a given pair of dates. This takes
all entries between those dates, and totals them across each account.
A trial balance of the general ledger across all dates.

When a journal is posted, it is added to the journal that is the general
ledger.

When a recurring journal is posted it is, like a regular journal, added to
the general ledger.

A journal has certain characteristics, one of which is Repeater
characteristics. A journal can be one-off, in which case it is posted only
once; or it can be recurring.

Changes in a journal's Repeater characteristics and also other
"meta-characteristics", are also logged in the journal itself.


An account has a commodity and quantity.
We could have accounts that have a unique commodity (a particular book, for
example), and a quantity of one.

A commodity must be defined to convert to the base commodity for a given
ledger, at a particular rate. The rate could be nil.

A superacccount will still have a given commodity, and will have a balance
that is the sum of its children's balances, after each is converted into the
superaccount's commodity.

...

Should I have interface classes for accounts etc.? Then each instance of the
interface class could have a single data member being a (smart) pointer to
the underlying account. At the moment I can't see any pressing need to add
this extra layer of indirection; but I might do so later. I think it's best
to avoid complicating things unless and until I see the need.

I think I should definitely unit test this program on an ongoing basis during
development.















